)lisp (load "~/quicklisp/setup")
)lisp (ql:quickload "gsll")
)lisp (load "gsl.lisp")
)abbrev package GSL Gsl
++ GNU Scientific Library for Axiom (and FriCAS and OpenAxiom)
++ Date Created: October 25, 2015
++ License: BSD  (GSL is distributed under the GPL)
++ Date Last Updated: October 26, 2015
++ Basic Operations: integration
++ Related Domains: DoubleFloat
++ Also See:
++ AMS Classifications:
++ Keywords: GNU; GSL; numeric; integration
++ Examples: gslIntegrationQng(f,0.0::DF,1.0::DF).result
++ References:
++   https://common-lisp.net/project/gsll/
++   http://www.gnu.org/software/gsl/
++   http://www.gnu.org/software/gsl/manual/gsl-ref.html
++ Description:
++   Provides an interface to the routines of the GNU Scientific Library.
++   http://www.gnu.org/software/gsl/manual/
++ Author(s):
++   Kurt Pagani, Alasdair McAndrew, Bill Page
Gsl() : Exports == Implementation where

  DF ==> DoubleFloat

  Exports ==  with

    lookup: String -> Symbol
      ++ \spad{\gslLookup} finds GSLL function by GSL name and
      ++ displays some documentation.
    isNaN?: DF -> Boolean
      ++ \spad{\gslIsNaN?} returns true if x is not-a-number. 
    isInf: DF -> Integer
      ++ \spad{\gslIsInf} returns +1 if x is positive infinity,
      ++ -1 if x is negative infinity and 0 otherwise. On
      ++ some platforms 1 is returned for negative infinity.
    finite?: DF -> Boolean
      ++ \spad{\gslFinite?} returns true if x is a real number,
      ++ and false if it is infinite or not-a-number.
    fcmp: (DF,DF,DF) -> Integer
      ++ \spad{\gslFcmp} determines whether x and y are approximately
      ++ equal to a relative accuracy epsilon. If x and y lie
      ++ within this interval, they are considered approximately equal
      ++ and the function returns 0. Otherwise if x < y, the function
      ++ returns -1, or if x > y, the function returns +1. Note that
      ++ this function is not suitable for testing whether a value is
      ++ approximately zero.
    integrationQng: (DF -> DF,DF,DF) -> Record(result:DF, abserr:DF, neval:Integer)
      ++ \spad{\gslIntegrationQng}  applies the Gauss-Kronrod 10-point, 
      ++ 21-point, 43-point and 87-point integration rules in succession
    LUdecomposition: Matrix DF -> Record(LU:Matrix DF,Perm:Vector Integer,Sign:Integer)

  Implementation ==  add

    lookup(s) ==
      j:SExpression := GSL_-LOOKUP(s)$Lisp
      if not null? j then
        DESCRIBE(symbol(j))$Lisp
      symbol(j)
    isNaN?(a) == NANP(a)$Lisp      
    finite?(a) == FINITEP(a)$Lisp      
    isInf(a) ==
      r:SExpression := ISINF(a)$Lisp
      null? r => 0
      integer r
    fcmp(x,y,epsilon) ==
      r:SExpression := DOUBLE_-FLOAT_-UNEQUAL(x,y,epsilon)$Lisp
      null? r => 0
      integer r
    --
    integrationQng(f,a,b) ==
      INTEGRATIONQNG(
        -- convert returned values to Spad representation
        (v1:DF,v2:DF,v3:Integer):Record(result:DF, abserr:DF, neval:Integer)+->[v1,v2,v3],
        f,a,b)$Lisp
    --
    LUdecomposition(A) == LUDECOMP(
      -- convert returned values to Spad representation
      (v1:List List DF, v2: List Integer,v3:Integer):Record(LU:Matrix DF,Perm:Vector Integer,Sign:Integer) +->
        [matrix v1,vector v2,v3],
      listOfLists A,nrows A,ncols A)$Lisp

